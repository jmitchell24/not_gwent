//
// Created by james on 10/29/23.
//

#include "ledit/ledit_box.hpp"
#include "ledit/ledit_box_visitor.hpp"
#include "ledit/ledit_options.hpp"
using namespace ledit;

//
// imgui
//
#include "rlImGui/imgui/imgui_mods.hpp"
#include "rlImGui/extras/lucide_icons.hpp"

//
// ut
//
#include <ut/check.hpp>
using namespace ut;

//
// std
//
using namespace std;

//
// BoxVisitor -> Implementation
//

BoxVisitor* BoxVisitor::m_current_instance = nullptr;

BoxVisitor::BoxVisitor(cstrparam name)
    : m_name{name.str()}
{ }

string const& BoxVisitor::name() const
{
    return m_name;
}

boxmap_t const& BoxVisitor::boxMap() const
{
    return m_box_map;
}

rect BoxVisitor::getRealRect(rect const& r) const
{
    if (view_transform)
    {
        return view_transform->realRect(r);
    }
    return r;
}

vec2 BoxVisitor::getViewPoint(vec2 const& p) const
{
    if (view_transform)
    {
        return view_transform->viewPoint(p);
    }
    return p;
}

string BoxVisitor::toCPPString()
{
    stringstream ss;

    auto b = m_box_map.begin();
    auto e = m_box_map.end();

    ss << "// *** auto-generated by ledit *** \n";

    for (auto&& it : m_box_map)
    {
        if (auto const& box = it.second)
        {
            ss << PRINTER("%-45s = ut::rect(%8.3ff, %8.3ff, %8.3ff, %8.3ff);\n",
                PRINTER("%s.outer", box->name.c_str()).c_str(),
                box->lb.outer.pack[0],
                box->lb.outer.pack[1],
                box->lb.outer.pack[2],
                box->lb.outer.pack[3]);

            ss << PRINTER("%-45s = ut::rect(%8.3ff, %8.3ff, %8.3ff, %8.3ff);\n",
                PRINTER("%s.border", box->name.c_str()).c_str(),
                box->lb.border.pack[0],
                box->lb.border.pack[1],
                box->lb.border.pack[2],
                box->lb.border.pack[3]);

            ss << PRINTER("%-45s = ut::rect(%8.3ff, %8.3ff, %8.3ff, %8.3ff);\n",
                PRINTER("%s.inner", box->name.c_str()).c_str(),
                box->lb.inner.pack[0],
                box->lb.inner.pack[1],
                box->lb.inner.pack[2],
                box->lb.inner.pack[3]);
        }
    }

    ss << "// *** auto-generated by ledit *** \n";

    return ss.str();
}

void BoxVisitor::setActive()
{
    LEDIT_OPTIONS.active_editor_name = m_name;
    is_overlay_visible = true;
    want_capture_mouse = true;
}

void BoxVisitor::clearActive()
{
    LEDIT_OPTIONS.active_editor_name.clear();
    is_overlay_visible = false;
    want_capture_mouse = false;
}

bool BoxVisitor::isActive() const
{
    return LEDIT_OPTIONS.active_editor_name == m_name;
}

void BoxVisitor::setGlobalInstance()
{
    m_current_instance = this;
}

void BoxVisitor::clearGlobalInstance()
{
    m_current_instance = nullptr;
}

BoxVisitor& BoxVisitor::currentInstance()
{
    check_null(m_current_instance);
    return *m_current_instance;
}

//
// Box Slot
//

box_ptr BoxVisitor::getBoxSlot(cstrparam s)
{
    auto k = s.str();

    if (auto it = m_box_map.find(k); it != m_box_map.end())
    {
        if (auto&& v = it->second)
            return v;
    }

    return m_box_map[k] = nullptr;
}

bool BoxVisitor::trySetBoxSlot(box_ptr const& ptr)
{
    if (auto it = m_box_map.find(ptr->name); it != m_box_map.end())
    {
        auto&& v = it->second;
        if (v && v != ptr)
            v->name.clear();
        v = ptr;
        return true;
    }
    return false;
}

void BoxVisitor::resetBoxSlot(box_ptr const& ptr)
{
    if (auto it = m_box_map.find(ptr->name); it != m_box_map.end())
    {
        auto&& v = it->second;
        v = nullptr;
        ptr->name.clear();
    }
}

void BoxVisitor::resetAllSlots()
{
    for (auto&& it : m_box_map)
        it.second = nullptr;
}

size_t BoxVisitor::getSlotCount() const
{
    return m_box_map.size();
}

size_t BoxVisitor::getFilledSlotCount() const
{
    return m_box_map.size() - getEmptySlotCount();
}

size_t BoxVisitor::getEmptySlotCount() const
{
    size_t count = 0;
    for (auto&& it : m_box_map)
        if (it.second == nullptr)
            ++count;
    return count;
}

void BoxVisitor::setBoxSlotAll(box_ptr const& ptr)
{
    if (!ptr->name.empty())
        m_box_map[ptr->name] = ptr;

    for (auto&& it : ptr->child_boxes)
        setBoxSlotAll(it);
}

//
// Box Selection
//

void BoxVisitor::setSelectedBoxSingle(box_ptr const& ptr)
{
    m_selected_box_single = ptr;
    m_selected_box_multi.clear();
}

void BoxVisitor::setSelectedBoxMulti(box_ptr const& ptr)
{
    if (m_selected_box_single == ptr)
        return;
    for (auto&& it : m_selected_box_multi)
        if (it == ptr)
            return;
    m_selected_box_multi.push_back(ptr);
}

void BoxVisitor::toggleSelectedBoxMulti(box_ptr const& ptr)
{
    if (m_selected_box_single == ptr)
        return;
    if (hasBoxSelectionSingle())
    {
        auto b = m_selected_box_multi.begin();
        auto e = m_selected_box_multi.end();
        for (auto it = b; it != e; ++it)
        {
            if (*it == ptr)
            {
                m_selected_box_multi.erase(it);
                return;
            }
        }
        m_selected_box_multi.push_back(ptr);
    }
}

void BoxVisitor::setMutateSelection(box_ptr const& ptr)
{
    if (ptr)
    {
        m_selected_box_single = nullptr;
        m_selected_box_multi.clear();

        if (auto parent = ptr->parent)
        {
            for (auto&& it : parent->child_boxes)
            {
                if (it == ptr)
                    m_selected_box_single = it;
                else
                    m_selected_box_multi.push_back(it);
            }
        }

        check(m_selected_box_single != nullptr, "invalid box hierarchy detected");
    }
}

void BoxVisitor::clearSelectedBoxSingle()
{
    m_selected_box_single = nullptr;
    m_selected_box_multi.clear();
}

void BoxVisitor::clearSelectedBoxMulti(box_ptr const& ptr)
{
    auto b = m_selected_box_multi.begin();
    auto e = m_selected_box_multi.end();
    for (auto it = b; it != e; ++it)
    {
        if (*it == ptr)
        {
            m_selected_box_multi.erase(it);
            return;
        }
    }
}
void BoxVisitor::clearSelectedBoxMultiAll()
{
    m_selected_box_multi.clear();
}

bool BoxVisitor::isBoxSelectedSingle(box_ptr const& ptr) const
{
    return m_selected_box_single == ptr;
}

bool BoxVisitor::isBoxSelectedMulti(box_ptr const& ptr) const
{
    for (auto&& it : m_selected_box_multi)
        if (it == ptr)
            return true;
    return false;
}

bool BoxVisitor::hasBoxSelectionSingle() const
{
    return m_selected_box_single != nullptr;
}

bool BoxVisitor::hasBoxSelectionMulti() const
{
    return !m_selected_box_multi.empty();
}


bool BoxVisitor::canMutate() const
{
    if (!m_selected_box_single)
        return false;

    if (m_selected_box_multi.empty())
        return false;

    auto parent = m_selected_box_single->parent;
    if (!parent)
        return false;

    for (auto&& it : m_selected_box_multi)
        if (parent != it->parent)
            return false;
    return true;
}

box_ptr BoxVisitor::boxSelectionSingle() const
{
    return m_selected_box_single;
}

boxlist_t BoxVisitor::boxSelectionMulti() const
{
    return m_selected_box_multi;
}

bool BoxVisitor::drawSelectionButton(box_ptr const& ptr) const
{
    using namespace ImGui;

    if (isBoxSelectedSingle(ptr))
        return SmallButton("o", WC_HIGHLIGHT);
    if (isBoxSelectedMulti(ptr))
        return SmallButton("*", WC_VIOLET);
    return SmallButton(" ");
}